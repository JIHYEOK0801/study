# 70. 개발 환경 구축(C)

1. ### 개발 환경 구축

   개발 프로젝트를 이해하고 소프트웨어 및 하드웨어 장비를 구축하는 것

   </br>

2. ### 하드웨어 환경

   사용자와의 인터페이스 역할을 하는 **클라이언트**, 클라이언트와 통신하여 서비스를 제공하는 **서버**로 구성

   - 클라이언트

     개인용 컴퓨터(PC), 스마트폰 등

   - 서버

     웹서버, 웹 어플리케이션 서버, 데이터베이스 서버, 파일 서버 등

   </br>

3. ### 소프트웨어 환경

   클라이언트와 서버 운영을 위한 **시스템 소프트웨어**와 개발에 사용되는 **개발 소프트웨어**로 구성

   - 시스템 소프트웨어

     운영체제, 서버 프로그램, DBMS 등

   - 개발 소프트웨어

     요구사항 관리도구, 설계/모델링 도구, 구현 도구, 빌드 도구, 테스트 도구, 형상 관리 도구

   </br>

4. ### 웹서버의 기능

   | 기능            | 내용                                                         |
   | --------------- | ------------------------------------------------------------ |
   | HTTP/HTTPS 지원 | 브라우저로부터 요청을 받아 응답할 때 사용되는 프로토콜       |
   | 통신 기록       | 처리한 요청들을 로그 파일로 기록하는 기능                    |
   | 정적 파일 관리  | HTML, CSS, 이미지 등의 정적 파일들을 저장하고 관리하는 기능  |
   | 대역폭 제한     | 네트워크 트래픽의 포화를 방지하기 위해 응답 속도를 제한하는 기능 |
   | 가상 호스팅     | 하나의 서버로 여러개의 도메인 이름을 연결하는 기능           |
   | 인증            | 사용자가 합법적인 사용자인지를 확인하는 기능                 |

   </br>

5. ### 개발 언어의 선정 기준

   | 기준   | 내용                                                       |
   | ------ | ---------------------------------------------------------- |
   | 적정성 | 개발하려는 소프트웨어의 목적에 적합해야함                  |
   | 효율성 | 코드의 작성 및 구현이 효율적이어야 함                      |
   | 이식성 | 다양한 시스템및 환경에 적용이 가능해야 함                  |
   | 친밀성 | 개발 언어에 대한 개발자들의 이해도와 활용도가 높아야 함    |
   | 범용성 | 다른 개발 사례가 존재하고 여러 분야에서 활용되고 있어야 함 |

   </br></br>

# 71. 소프트웨어 아키텍처(B)

1. ### 소프트웨어 아키텍처

   소프트웨어를 구성하는 요소들 간의 관계를 표현하는 시스템의 구조 또는 구조체

   </br>

2. ### 모듈화

   시스템의 기능들을 모듈 단위로 나누는 것

   - 장점 : 소프트웨어 성능 향상 / 시스템의 수정 및 재사용 / 유지 관리 등

   </br>

3. ### 추상화

   전체적이고 포괄적인 개념을 설계한 후 구체화 시켜 나가는 것

   - 유형

     | 종류          | 내용                                                         |
     | ------------- | ------------------------------------------------------------ |
     | 과정 추상화   | 자세한 과정은 정의하지 않고, 전반적인 흐름만 파악하도록 설계하는 방법 |
     | 데이터 추상화 | 데이터의 세부적인 속성이나 용도를 정의하지 않고, 데이터 구조를 대표할 수 있는 표현으로 대체하는 방법 |
     | 제어 추상화   | 이벤트 발생의 정확한 절차나 방법을 정의하지 않고, 대표할 수 있는 표현으로 대체하는 방법 |

     </br>

4. ### 단계적 분해

   상위의 중요 개념부터 하위의 개념으로 구체화 시키는 분할 기법

   </br>

5. ### 정보 은닉

   모듈 내부에 포함된 절차와 자료들의 정보가 감추어져 다른 모듈이 접근하거나 변경하지 못하도록 하는 기법

   </br>

6. ### 상위 설계 / 하위설계

   |           | 상위설계                 | 하위설계                      |
   | --------- | ------------------------ | ----------------------------- |
   | 별칭      | 아키텍처 설계, 예비 설계 | 모듈 설계, 상세 설계          |
   | 설계 대상 | 시스템의 전체적인 구조   | 시스템의 내부 구조 및 행위    |
   | 세부 목록 | 구조, DB, 인터페이스     | 컴포넌트, 자료 구조, 알고리즘 |

   </br>

7. ### 소프트웨어 아키텍처의 품질 속성

   - 품질 평가 요소의 종류

     | 종류          | 내용                                                       |
     | ------------- | ---------------------------------------------------------- |
     | 시스템 측면   | 성능, 보안, 가용성, 기능성, 사용성, 변경 용이성, 확장성 등 |
     | 비즈니스 측면 | 시장 적시성, 비용과 혜택, 예상 시스템 수명 등              |
     | 아키텍처 측면 | 개념적 무결성, 정확성, 완결성 등                           |

     </br>

8. ### 소프트웨어 아키텍처의 설계 과정

   1. ##### 설계 목표 설정

   2. ##### 시스템 타입 결정

   3. ##### 아키텍처 패턴 적용

   4. ##### 서브시스템 구체화

   5. ##### 검토

   </br>

9. ### 협약에 의한 설계

   - 컴포넌트를 설계할 때 클래스에 대한 여러 가정을 공유할 수 있도록 명세한 것

   - 컴퓨넌트에 대한 정확한 인터페이스를 명세한다

   - 명세에 포함될 조건

     | 조건      | 내용                                               |
     | --------- | -------------------------------------------------- |
     | 선행 조건 | 오퍼레이션이 호출되기 전에 참이 되어야 할 조건     |
     | 결과 조건 | 오퍼레이션이 수행된 후 만족되어야 할 조건          |
     | 불변 조건 | 오퍼레이션이 실행되는 동안 항상 만족되어야 할 조건 |

</br></br>

# 72. 아키텍처 패턴(B)

1. ### 아키텍처 패턴

   - 아키텍처를 설계할 때 참조할 수 있는 전형적인 해결 방식
   - 시스템의 구조를 구성하기 위한 기본적인 윤곽 제시

   </br>

2. ### 레이어 패턴

   - 시스템을 계층으로 구분하여 구성하는 고전적인 패턴
   - OSI참조 모델이 대표적인 모델

   </br>

3. ### 클라이언트-서버 패턴

   - 하나의 서버 컴포넌트와 다수의 클라이언트 컴포넌트로 구성되는 패턴

   </br>

4. ### 파이프-필터 패턴

   - 데이터 스트림 절차의 각 단계를 필터로 캡슐화 하여 파이프를 통해 전송하는 패턴
   - 데이터 변환, 버퍼링, 동기화 등에 사용

   </br>

5. ### 모델-뷰-컨트롤러 패턴

   - 서브 시스템을 모델, 뷰, 컨트롤러로 구조화하는 패턴
   - 대화형 어플리케이션에 적합

   </br>

6. ### 기타 패턴(예시는 책 참고)

   | 종류                 | 내용                                                         |
   | -------------------- | ------------------------------------------------------------ |
   | 마스터-슬레이브 패턴 | 슬레이브 컴포넌트에서 처리된 결과물을 다시 돌려받는 방식으로 작업을 수행 |
   | 브로커 패턴          | 사용자가 원하는 서비스와 특성을 브로커 컴포넌트에 요청하면 브로커 컴포넌트가 요청에 맞는 컴포넌트를 연결 |
   | 피어-투-피어 패턴    | 피어라고 불리는 하나의 컴포넌트가 클라이언트가 될수도, 서버가 될 수도 있는 패턴 |
   | 이벤트-버스 패턴     | 소스가 특정 채널에 이벤트 메시지를 발행하면, 해당 채널을 구독한 리스너들이 메시지를 받아 이벤트를 처리하는 패턴 |
   | 블랙보드 패턴        | 모든 컴포넌트들이 공유 데이터 저장소와 블랙보드 컴포넌트에 접근이 가능한 패턴 |
   | 인터프리터 패턴      | 프로그램 코드의 각 라인을 수행하는 방법을 지정하고, 기호마다 클래스를 갖도록 구성된 패턴 |

</br></br>

# 73. 객체지향(A)

1. ### 객체지향

   - 소프트웨어의 각 요소들을 객체로 만든 후, 객체들을 조립해서 소프트웨어를 개발하는 기법
   - 재사용 및 확장이 용이하며 고품질의 소프트웨어를 빠르게 개발할 수 있고 유지보수가 쉽다
   - 객체지향의 구성요소
     - 객체
     - 클래스
     - 메시지
   - 객체지향의 특징
     - 캡슐화
     - 다형성
     - 상속
     - 연관성

   </br>

2. ### 객체

   데이터와 이를 처리하기 위한 함수를 묶어 놓은 소프트웨어 모듈

   - 데이터

     객체가 가지고 있는 정보

   - 함수

     객체가 수행하는 기능

   </br>

3. ### 클래스

   - 공통된 속성과 연산을 갖는 객체의 집합
   - 각각의 객체들이 갖는 속성과 연산을 정의하고 있는 틀

   </br>

4. ### 메시지

   - 객체들 간의 상호작용에 사용되는 수단으로, 객체의 동작이나 연산을 일으키는 외부의 요구 사항

   </br>

5. ### 캡슐화

   - 외부에서 접근을 제한하기 위해 인터페이스를 제외한 세부내용을 은닉하는 것

   </br>

6. ### 상속

   - 상위 클래스의 모든 속성과 연산을 하위 클래스가 물려받는 것

   </br>

7. ### 다형성

   - 하나의 메시지에 대해 각각의 객체가 가지고 있는 고유한 방법으로 응답할 수 있는 능력

   </br>

8. ### 연관성

   - 두 개 이상의 객체들이 상호 참조하는 관계

   - 연관성의 종류

     | 종류           | 의미                          | 특징                                                         |
     | -------------- | ----------------------------- | ------------------------------------------------------------ |
     | is member of   | 연관화                        | 2개 이상의 객체가 상호 관련되어 있음을 의미함                |
     | is instance of | 분류화                        | 동일한 형의 특성을 갖는 객체들을 모아 구성하는 것            |
     | is part of     | 집단화                        | 관련 있는 객체들을 묶어 하나의 상위 객체를 구성하는 것       |
     | is  a          | - 일반화<br />- 특수화/상세화 | - 공통적인 성질들로 추상화한 상위 객체를 구성하는 것<br />- 상위 객체를 구체화 하여 하위 객체를 구성하는 것 |

</br></br>

# 74. 객체지향 분석 및 설계(A)

1. ### 객체지향 분석(OOA)

   - 사용자의 요구사항과 관련된 객체, 속성, 연산, 관계 등을 정의하여 모델링하는 작업
   - 클래스를 식별하는 것이 객체 지향 분석의 주요 목적

   </br>

2. ### 객체지향 분석의 방법론

   | 종류                  | 내용                                                         |
   | --------------------- | ------------------------------------------------------------ |
   | Rumbaugh(럼바우) 방법 | 객체 모델, 동적 모델, 기능 모델로 나누어 수행                |
   | Booch(부치) 방법      | - 미시적 개발 프로세스와 거시적 개발 프로세스를 모두 사용<br />- 클래스와 객체들을 분석 및 식별하고 클래스의 속성과 연산을 정의함 |
   | Jacobson 방법         | 유스케이스를 강조하여 사용함                                 |
   | Coad와 Yourdon 방법   | - E-R 다이어그램을 사용하여 객체의 행위를 모델링<br />- 객체 식별, 구조 식별, 주제 정의, 속성과 인스턴스 연결 정의, 연산과 메시지 연결 정의 등의 과정으로 구성 |
   | Wirfs-Brock 방법      | 분석과 설계 간의 구분이 없고, 고객 명세서를 평가해서 설계 작업까지 연속적으로 수행함 |

   </br>

3. ### 럼바우의 분석기법

   - 모든 소프트웨어 구성요소를 그래픽 표기법을 이용하여 모델링하는 기법
   - 객체 모델링 기법(OMT) 라고도 한다
   - 객체 모델링 > 동적 모델링 > 기능 모델링 순으로 이뤄진다

   </br>

4. ### 객체지향 설계 원칙

   - 변경이나 확장에 유연한 시스템을 설계하기 위해 지켜야할 원칙

   - 객체지향 설계 원칙의 종류(SOLID)

     | 종류                      | 내용                                                         |
     | ------------------------- | ------------------------------------------------------------ |
     | 단일 책임 원칙(SRP)       | 객체는 단 하나의 책임만 갖는다                               |
     | 개방-폐쇄 원칙(OCP)       | 기존의 코드를 변경하지 않고 기능을 추가할 수 있도록 설계해야 한다 |
     | 리스코프 치환 원칙(LSP)   | 자식 클래스는 최소한 부모 클래스의 기능은 수행할 수 있어야 한다는 원칙 |
     | 인터페이스 분리 원칙(ISP) | 자신이 사용하지 않는 인터페이스와 의존 관계를 맺거나 영향을 받지 않아야 한다는 원칙 |
     | 의존 역전 원칙(DIP)       | 의존 관계성립 시 추상성이 높은 클래스와 의존 관계를 맺어야 한다는 원칙 |

     
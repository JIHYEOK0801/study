## JAVA

- [자바언어의 특징](#자바-언어의-특징)
- [메소드 오버로딩과 메소드 오버라이딩의 차이](#메소드-오버로딩과-오버라이딩)
- [접근지정자 public, 디폴트, protected, private 의 차이?](#publicprotecteddefaultprivate)
- [static과 non-static의 차이?](#static과-non-static)
- [객체 지향언어에서 상속이 주는 장점](#객체-지향언어에서-상속이-주는-장점)
- [서브클래스가 생성될 때 어떤일이 일어나는가?](#서브클래스가-생성될-때-어떤일이-일어나는가)
- [추상클래스와 인터페이스의 차이](#추상클래스와-인터페이스의-차이)
- [멀티프로세싱과 멀티쓰레딩의 차이](#멀티프로세싱과-멀티쓰레딩의-차이)
- [자바에서 스레드를 만드는 2가지 방법](#자바에서-스레드를-만드는-2가지-방법)
- [자바의 스레드 종류 2가지](#자바의-스레드-종류-2가지)
- [자바 스레드의 스케줄링](#자바-스레드의-스케줄링)
- [자바에서 스레드 동기화를 하는 방법 2가지](#자바에서-스레드-동기화를-하는-방법-2가지)

</br></br>

> ### 자바 언어의 특징

1. C/C++ 언어와 다르게 플랫폼 독립적이다.

   운영체제와 상관없이 자바 컴파일러(javac), 자바 가상머신(JVM)이 있으면 소스코드를 실행할 수 있다.

   다수의 클래스파일을 jar파일 형태로 압축하여 배포하거나 실행가능하다.

   </br>

2. 객체 지향 언어이다.

   객체 지향언어의 특징 세가지 : 캡슐화, 상속, 다형성

   </br>

3. 관련있는 클래스를 패키지로 묶어 관리한다.

   패키지는 파일 시스템의 폴더와 같은 개념

   </br>

4.  멀티스레드 실행환경을 지원한다.

   운영체제의 도움 없이 멀티스레드 프로그래밍이 가능하다. (**멀티스레드를 지원하지 않는 운영체제에서도**)

   </br>

5. 자동으로 메모리 관리가 된다.

   가비지 컬렉션으로 메모리가 자동으로 회수된다.(**가비지 컬랙션은 우리가 작동시킬 수 없다.**)

   </br>

6. 실시간 응용시스템에 부적합하다.

   가비지 컬렉션이 예측할 수 없는 때에 실행되기 때문(**가비지 컬렉션이 실행될 때는 우리눈에 멈춘것 처럼 보이기 때문**)

</br></br>

> ### 메소드 오버로딩과 오버라이딩

### 오버로딩(= 메소드 중복)

한 클래스 내에, **이름은 같지만 매개변수의 타입이나 개수가 서로 다른** 여러개의 메소드를 작성하는 것

</br>

### 오버라이딩(=동적바인딩)

**슈퍼클래스에 선언된 메소드와 같은 메소드를 서브클래스에 선언**하여 다르게 작성하는 것

오버라이딩의 목적은 **다형성** 실현

</br></br>



> ### public,protected.default,private

### 클래스 접근 지정자

**public** : 패키지 관계없이 어떤 클래스든 사용 허용

**default** : 같은 패키지 내의 클래스들에게만 허용

</br>

### 멤버 접근 지정

아래로 갈수록 범위가 좁아짐

**public** : 패키지 관계없이 어떤 클래스든 사용 허용

**protected** : 같은 패키지와 자식 클래스까지 허용

**default** : 같은 패키지 내의 클래스들에게만 허용

**private** : 클래스 내에서만 허용

</br></br>

> ### static과 non-static

**static 멤버** 

main()메소드 실행시 이미 생성 되어있다. (JVM이 실행되는 시점에 생성된다.)

다른 객체들과 멤버 공유. 

**클래스멤버**라고도 한다.

**전역변수, 전역함수, 공유멤버**를 만들때 사용한다.

static 메소드는 static 멤버만 접근할 수 있다.(this 사용 불가능)

</br>

**non-static 멤버** 

객체 생성시 생성. 

다른객체들과 멤버를 공유하지 않는다. 

**인스턴스 멤버**라고도 한다.

</br></br>

> ### 객체 지향언어에서 상속이 주는 장점

1. 클래스의 간결화
2. 클래스 관리 용이
3. 소프트웨어의 생산성 향상

</br>

JAVA는 **다중상속 불가**

하지만 **상속 횟수는 제한 없음**

계층 구조의 최상위는 **java.lang.Object 클래스**

</br></br>

> ### 서브클래스가 생성될 때 어떤일이 일어나는가?

슈퍼클래스의 생성자가 먼저 실행되고,

서브클래스의 생성자가 실행된다.

생성자는 각자의 클래스에 맞는 멤버 변수들을 초기화 한다.

</br>

슈퍼클래스의 생성자가 여러개라면

서브클래스의 생성자에서 **super()로 슈퍼클래스의 생성자를 지정**

</br></br>

> ### 추상클래스와 인터페이스의 차이

추상클래스의 목적은 서브클래스에서 필요한 대부분의 기능은 작성, 서브클래스에서밖에 작성할수 없는 것은 서브클래스에서 작성

</br>

인터페이스의 목적은 인터페이스의 모든 추상메소드를 객체가 구현하게끔 하는 것

</br>

**추상클래스**

추상메소드와 일반 메소드 모두 포함

상수, 변수 필드 모두 포함

</br>

**인터페이스**

추상메소드와 상수필드만 포함

다중상속 지원

</br></br>

> ### 멀티프로세싱과 멀티쓰레딩의 차이

**멀티 프로세싱**

하나의 프로그램을 여러개의 프로세스로 구성하여, 각 프로세스가 하나의 작업을 처리하는 기법

각 프로세스는 **고유한 메모리영역을 보유하고 독립적으로 실행**

프로세스간 통신(IPC)를 한다고 해도 오버헤드가 크기 때문에 멀티스레딩을 사용

</br>

**멀티 쓰레딩**

하나의 프로그램을 여러개의 작업으로 나눠서, 각 스레드마다 하나의 작업을 처리하는 기법

모든 스레드는 **응용프로그램 내의 자원과 메모리를 공유**한다.

</br>

자바는 프로세스가 존재하지 않고, 스레드 개념만 존재한다

JVM은 멀티스레딩만 지원한다. **자바 스레드**는 **JVM에 의해 스케줄되는 실행단위 코드블록**

</br>

자바에서 **스레드 스케줄링은 전적으로 JVM에 의해서 이뤄진다.**

</br></br>

> ### 자바에서 스레드를 만드는 2가지 방법

1. Thread 클래스 이용
2. Runnable 인터페이스 상속

</br></br>

> ### 자바의 스레드 종류 2가지

1. 데몬스레드

   응용프로그램이 실행되는동안 **관리를 위해 존재하는 스레드**. 대표적으로 가비지 컨렉션 스레드가 있다.

   </br>

2. 사용자스레드

   **응용프로그램에서 생성한 스레드**. 

</br>

차이 : 사용자 스레드가 모두 종료되면 JVM과 함께 응용프로그램도 종료된다.

</br></br>

> ### 자바 스레드의 스케줄링

기본적으로는 **비선점 스케줄링**

</br>

JVM이 멀티스레딩을 지원하는 운영체제에서 실행되는 경우, **운영체제의 스레드를 자바 스레드에 매핑시켜 선점 스케줄링이 가능**하게 한다.

</br></br>

> ### 자바에서 스레드 동기화를 하는 방법 2가지

1. synchronized로 동기화 블록 지정

   진입할때 lock이 걸리고 나올때 unlock이 자동으로 이루어 지도록 컴파일된다.

   </br>

2. wait()-notify() 메소드로 스레드 실행 순서 제어

   두 스레드가 동시에 접근하는 **producer-consumer** 문제




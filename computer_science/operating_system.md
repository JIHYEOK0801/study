# 운영체제

1. ### [프로세스(process)](#프로세스)

   - #### [프로세스의 의미](#프로세스의-의미)
   - #### [프로세스의 구성요소](#프로세스의-구성-요소)
     
     - ##### 전역변수와 static 변수의 차이점은?
   - #### [프로세스 스케줄링이란?](#프로세스-스케줄링)
     
     - ##### 선점형 OS와 비선점형 OS의 차이점
     - ##### 스케줄링 알고리즘을 아는가?
   - #### [프로세스의 상태변화를 설명하시오](#프로세스의-상태변화)
     
     - ##### Running > Ready 와 Running > Blocked의 차이점은?
   - ##### [컨텍스트 스위칭이란?](#컨텍스트-스위칭)

2. ### [커널(kernel)](#커널)

   - #### [커널/커널 오브젝트의 의미](#커널의-의미)
   - #### [핸들의 의미](#핸들의-의미)
   - #### [커널오브젝트의 특징/핸들의 특징](#커널오브젝트와-핸들의-특징)
   
3. ### [쓰레드(thread)](#쓰레드)

   - #### [쓰레드의 의미](#쓰레드의-의미)
   
   - #### [프로세스와 쓰레드의 차이](#프로세스와-쓰레드의-차이)
     
     - ##### 쓰레드끼리 공유하는 요소란 무엇인가
     
     - ##### 커널 레벨 쓰레드와 유저 레벨 쓰레드란?
     
     - ##### 커널 영역과 유저 영역의 차이
     
     - ##### 커널 모드와 유저 모드의 차이
     
   - #### [쓰레드 동기화](#쓰레드-동기화)
   
     - ##### 쓰레드 동기화의 의미와 종류

</br></br>

# 프로세스

> ## 프로세스의 의미

메모리 할당이 이루어지고 실행중인 프로그램을 의미

</br></br>

> ## 프로세스의 구성 요소

| 구성 요소 | 내용                     |
| --------- | ------------------------ |
| code      | 실행파일의 명령어가 저장 |
| data      | 전역변수, static 변수    |
| stack     | 지역변수, 인자값 등      |
| heap      | 동적할당을 위해 존재     |

### 전역변수와 static 변수의 차이점은?

- ##### 전역변수

  다른 파일에서도 쓸 수 있는 변수

- ##### static변수

  선언된 파일만 접근 가능한 변수

</br></br>

> ## 프로세스 스케줄링

프로세스의 CPU할당 순서 및 방법을 결정하는 일

#

#

#

- #### 스케줄러

  스케줄링을 담당하는 소프트웨어 요소. 운영체제의 요소이다.
  
  </br>

#### 선점형 OS와 비선점형 OS의 차이점

**선점형 OS**는 우선순위가 높은 프로세스가 생성될 경우 해당 프로세스에게 CPU를 할당하는 시스템.

비선점형 OS에 비해 스케줄러가 하는 작업이 많다.

스케줄러가 실행순서를 조절해주다보니 프로그래머는 우선순위에 대해 거의 신경 쓰지 않아도 되니, 멀티 프로세스 기반 OS에 적합하다.

오늘날 접하는 모든 OS는 선점형 OS라고 생각하면 된다.(ex. Windows)

</br>

**비선점형 OS**는 현재 실행중인 프로세스가 CPU를 양보할 때까지, 혹은 I/O 작업 등으로 블로킹 상태에 놓일 때까지 CPU를 사용하는 것. 

따라서 프로그래머가 프로그램 설계시 프로그램의 우선순위를 잘 설계해야 한다.

인터렉티브한 프로그램 구현시 문제점 발생.

</br>

</br>

#### 스케줄링 알고리즘을 아는가?

- 우선순위 스케줄링

  각각의 프로세스마다 우선순위를 부여해서 우선순위가 높은 프로세스를 먼저 실행시키는 방식

- 라운드 로빈 스케줄링

  정해진 시간간격만큼 실행을 하고 (우선순위가 동일한 것 먼저) 다른 프로세스에게 CPU의 할당을 넘기는 방식

</br></br>

> ## 프로세스의 상태변화

<img src="./img/os_img_01.jpg" style="zoom:50%;margin-left:0" />

1. ### Start > Ready

   프로세스가 생성된 상태. 프로세스는 생성되면 바로 Ready상태가 되어 CPU할당을 기다린다

2. ### Ready > Running

   프로세스가 스케줄러에 의해 선택되어 CPU에서 실행되는 상태

3. ### Running > Ready

   우선순위가 더 높은 프로세스가 생겨서 실행되던 프로세스가 Ready상태로 변경

4. ### Running > Blocked

   데이터 입,출력으로 blocked상태로 변경

5. ### Blocked > Ready

   데이터 입,출력 완료 후 Ready상태로 변경

6. ### Blocked > Exit

   프로세스 종료

</br>

### Running > Ready 와 Running > Blocked의 차이점

- ##### **Running > Ready**

  우선순위가 더 높은 프로세스에게 CPU를 양보하는 과정

- ##### **Running > Blocked**

  데이터 입,출력 때문에 프로세스가 Blocked되는 과정

</br></br>

> ## 컨텍스트 스위칭

현재 실행중인 프로세스 관련 레지스터 정보를 메모리에 저장하고, 이제 실행할 프로세스 관련 레지스터 정보를 CPU의 레지스터에 가져오는 작업

</br>

실행되는 프로세스의 변경과정에서 발생하는 컨텍스트 스위칭은 시스템에 많은 부담을 준다.

</br>

</br>

# 커널

> ## 커널의 의미

- #### 커널

  컴퓨터를 운영하는 데 있어서 중심이 되는 운영체제 핵심 부분

- #### 커널 오브젝트

  프로세스, 쓰레드, 파일과 같은 리소스들을 원할하게 관리하기 위해 필요한 정보를 저장해야 하는데,

  이때 데이터를 저장한는 메모리 블록을 커널 오브젝트라고 한다

</br></br>

> ## 핸들의 의미

핸들이란 커널오브젝트를 간접적으로 변경시키기 위해 커널 오브젝트에 할당되는 숫자

</br></br>

> ## 커널오브젝트와 핸들의 특징

- #### 커널오브젝트

  1. 운영체제에 종속적이다. 
  2. 따라서, 커널 오브젝트의 소멸 시점은 운영체제에 의해서 결정된다.
  3. 또한, 여러 프로세스에 의해서 접근이 가능하다.

  </br>

- #### 핸들

  1. 프로세스에 종속적이다.

</br></br>

# 쓰레드

>## 쓰레드의 의미

하나의 프로그램 내에서 다수의 프로그램 흐름을 만들어 내기 위해 프로세스 내에 생성한 모델

</br>

> ## 프로세스와 쓰레드의 차이

- 프로세스는 데이터에 관해 서로 완벽히 독립적인 구조이다. 

  쓰레드는 같은 프로세스 내에서 서로 공유하는 요소들이 있다.

- 쓰레드는 공유하는 요소가 있기 때문에 컨텍스트 스위칭이 프로세스보다 빠르다.

</br>

### 쓰레드끼리 공유하는 요소란 무엇인가

메모리 구조상 프로세스는 code영역, data영역, stack영역, heap영역으로 구성됩니다.

쓰레드는 쓰레드가 생성될 때마다 해당 쓰레드를 위한 stack영역을 만들게 되고 나머지 code, data, stack영역은 공유하고 있습니다.

</br>

### 커널 레벨 쓰레드와 유저 레벨 쓰레드의 의미와 특징

**커널 레벨 쓰레드**란, 쓰레드를 생성하고 스케줄링 하는 주체가 커널일 경우를 뜻하고

**유저 레벨 쓰레드**란, 커널에서 쓰레드 기능을 지원하지 않을 때, 커널에 의존하지 않고 라이브러리를 활용하여 쓰레드의 기능을 써서 실행되는 쓰레드를 뜻합니다.

**커널 레벨 쓰레드**는 커널에서 직접 관리해주는 쓰레드이기 때문에 안전성이 뛰어나고 기본으로 제공되는 기능들이 있습니다.

**유저 레벨 쓰레드**는 커널에 의존하지 않기 때문에 커널모드와 유저모드의 전환이 없어서 성능이 좋습니다.

</br>

### 커널 영역과 유저 영역의 차이

커널 영역은 운영체제 동작시 사용하는 메모리 공간을 뜻하고,

유저 영역은 사용자가 원하는 프로그램 동작시 사용되는 메모리 공간(code, data, stack, heap)을 뜻합니다.

</br>

### 커널 모드와 유저 모드의 차이

**커널 모드**는 커널 영역에서 실행이 이뤄져야 할 경우 전환되는 모드이고,

**유저 모드**는 유저 영역에서 실행이 이뤄져야 할 경우 전환되는 모드입니다.

**유저 모드**에서는 커널 영역에 대한 접근이 불가능 하지만,

**커널 모드**에서는 모든 영역에 대한 접근이 가능합니다.

</br>

> ## 쓰레드 동기화

**임계영역**이란 **배타적 접근**(한 순간에 하나의 쓰레드만 접근)이 요구되는 공유 리소스에 접근하는 **코드블록**이다.

</br>

**동기화**란 **임계영역에 대한 동시접근을 막는 것**.

</br>

동기화 기법은 크게 **유저 모드 동기화, 커널 모드 동기화**로 나뉜다.

</br>

### 유저 모드 동기화

동기화 과정에서 커널을 사용하지 않는 동기화 기법. 커널을 사용하지 않기에 **성능상의 이점**이 있지만 **기능상의 제한**도 있다.

종류

- 크리티컬 섹션
- 인터락

### 커널 모드 동기화

동기화 과정에서 커널을 사용하는 동기화 기법. 커널을 사용하기 때문에 **성능의 저하**가 있지만 **커널에서 제공하는 기능**을 사용가능하다.

종류

- 뮤텍스
- 세마포어
- 이름있는 뮤텍스
- 이벤트

</br>

#### 크리티컬 섹션 기반 동기화

```c
CRITICAL_SECTION hCriticalSection;
LONG gTotalCount = 0;

void IncreaseCount(){
    EnterCriticalSection (&hCriticalSection);
    gTotalCount++; //임계영역
    LeaveCriticalSection (&hCriticalSection);
}
```

둘 이상의 쓰레드가 gTotalCount를 접근할 경우 동기화가 필요하다.

</br>

##### EnterCriticalSection

임계영역에 진입하기 위해 크리티컬 섹션 오브젝트의 주소값을 인자로 전달.

EnterCriticalSection이 다른 쓰레드에 의해서 호출된 상태이면, 호출 함수는 블로킹.

**LeaveCriticalSection**

임계영역을 빠져나온 후 호출.

블로킹 상태의 쓰레드가 있다면, 그 쓰레드는 임계영역 진입.

</br>

즉, 임계영역에 접근한 쓰레드가 있는지 확인하고 임계영역에 1개씩 들여보내는 방법.




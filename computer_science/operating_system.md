# 운영체제

1. ### [프로세스](#1-프로세스)

   - #### [프로세스의 의미](#1-1-프로세스의-의미)

   - #### [프로세스의 구성요소](#1-2-프로세스의-구성요소)
     
     - 전역변수와 static 변수의 차이점
     
   - #### [프로세스 스케줄링](#1-3-프로세스-스케줄링)
     
     - 선점형 OS와 비선점형 OS의 차이점
     - 스케줄링 알고리즘
     
   - #### [프로세스 상태변화](#1-4-프로세스-상태변화)
     
     - Running > Ready 와 Running > Blocked의 차이점
     
   - #### [컨텍스트 스위칭](#1-5-컨텍스트-스위칭)

2. ### [커널(kernel)](#커널)

   - #### [커널/커널 오브젝트의 의미](#커널의-의미)
   - #### [핸들의 의미](#핸들의-의미)
   - #### [커널오브젝트의 특징/핸들의 특징](#커널오브젝트와-핸들의-특징)
   
3. ### [쓰레드(thread)](#쓰레드)

   - #### [쓰레드의 의미](#쓰레드의-의미)
   
   - #### [프로세스와 쓰레드의 차이](#프로세스와-쓰레드의-차이)
     
     - ##### 쓰레드끼리 공유하는 요소란 무엇인가
     
     - ##### 커널 레벨 쓰레드와 유저 레벨 쓰레드란?
     
     - ##### 커널 영역과 유저 영역의 차이
     
     - ##### 커널 모드와 유저 모드의 차이
     
   - #### [쓰레드 동기화](#쓰레드-동기화)
   
     - ##### 쓰레드 동기화의 의미와 종류

</br></br>

# 1. 프로세스

> ## 1-1. 프로세스의 의미

메모리 할당이 이루어지고 실행중인 프로그램을 의미. 즉 메인메모리에서 실행되고 있는 프로그램.

</br>

> ## 1-2. 프로세스의 구성요소

| 구성 요소 | 내용                                  |
| --------- | ------------------------------------- |
| heap      | 동적할당 영역                         |
| stack     | 지역변수, 인자값 등이 저장되는 영역   |
| data      | 전역변수, static 변수가 저장되는 영역 |
| code      | 실행파일의 명령어가 저장되는 영역     |

### 전역변수와 static 변수?(C언어 기준)

**static 변수**는 선언된 함수 내에서만 사용 가능한 변수.

**전역변수**는 함수 외부에서 선언되어 프로그램내 어느 영역에서든 접근 가능한 변수.

**프로그램의 시작과 동시에 메모리 공간에 할당되어 종료 시까지 존재**하는 공통점.

</br>

> ## 1-3. 프로세스 스케줄링

**프로세스**의 **CPU할당 순서** 및 **방법**을 결정하는 일. **스케줄러**라는 운영체제의 소프트웨어가 담당한다.

</br>

### 선점형 OS와 비선점형 OS의 차이점

**선점형 OS**는 **우선순위가 높은 프로세스에게 CPU를 바로 할당**하는 시스템. 비선점형 OS에 비해 스케줄러가 하는 작업이 많다.

스케줄러가 실행순서를 조절해주고, 프로그래머는 우선순위에 대해 신경 쓰지 않아도 되어, **멀티 프로세스 기반 OS에 적합**하다.

오늘날 접하는 모든 OS의 유형.

</br>

**비선점형 OS**는 현재 **실행중인 프로세스가 CPU를 양보할 때까지, 혹은 I/O 작업 등으로 블로킹 상태에 놓일 때까지 기다렸다가 CPU를 할당**하는 시스템.

프로그래머가 프로그램 설계시 프로그램의 우선순위를 고려해야 한다. 인터렉티브한 프로그램 구현시 문제점 발생.

</br>

### 스케줄링 알고리즘

- #### 우선순위 스케줄링

  각각의 프로세스마다 **우선순위를 부여**해서 **우선순위가 높은 프로세스를 먼저 실행**시키는 방식

- #### 라운드 로빈 스케줄링

  **정해진 시간간격만큼 실행**을 하고 (우선순위가 동일한 것 먼저) **다른 프로세스에게 CPU의 할당을 넘기는 방식**

</br></br>

> ## 1-4. 프로세스 상태변화

<img src="./img/os_img_01.jpg" style="zoom:50%;margin-left:0" />

1. ### Start > Ready

   프로세스가 생성된 상태. 프로세스는 생성되면 바로 Ready상태가 되어 CPU할당을 기다린다

2. ### Ready > Running

   프로세스가 스케줄러에 의해 선택되어 CPU에서 실행되는 상태

3. ### Running > Ready

   우선순위가 더 높은 프로세스가 생겨서 실행되던 프로세스가 Ready상태로 변경

4. ### Running > Blocked

   데이터 입,출력으로 blocked상태로 변경

5. ### Blocked > Ready

   데이터 입,출력 완료 후 Ready상태로 변경

6. ### Blocked > Exit

   프로세스 종료

</br>

### Running > Ready 와 Running > Blocked의 차이점

**Running > Ready**는 **우선순위가 더 높은 프로세스에게 CPU를 양보**하는 과정에서 일어나고,**Running > Blocked**는 **데이터 입,출력 때문에 프로세스가 Blocked**되는 과정에서 일어난다.

</br>

> ## 1-5. 컨텍스트 스위칭

현재 **실행중인 프로세스 관련 레지스터 정보를 메모리에 저장**하고, **다음에 실행할 프로세스 관련 레지스터 정보를 CPU의 레지스터에 가져오는 작업**

실행되는 프로세스의 변경과정에서 발생하는 **컨텍스트 스위칭은 시스템에 많은 부담**을 준다.

</br>

</br>

# 커널

> ## 커널의 의미

- #### 커널

  컴퓨터를 운영하는 데 있어서 중심이 되는 운영체제 핵심 부분

- #### 커널 오브젝트

  프로세스, 쓰레드, 파일과 같은 리소스들을 원할하게 관리하기 위해 필요한 정보를 저장해야 하는데,

  이때 데이터를 저장한는 메모리 블록을 커널 오브젝트라고 한다

</br></br>

> ## 핸들의 의미

핸들이란 커널오브젝트를 간접적으로 변경시키기 위해 커널 오브젝트에 할당되는 숫자

</br></br>

> ## 커널오브젝트와 핸들의 특징

- #### 커널오브젝트

  1. 운영체제에 종속적이다. 
  2. 따라서, 커널 오브젝트의 소멸 시점은 운영체제에 의해서 결정된다.
  3. 또한, 여러 프로세스에 의해서 접근이 가능하다.

  </br>

- #### 핸들

  1. 프로세스에 종속적이다.

</br></br>

# 쓰레드

>## 쓰레드의 의미

하나의 프로그램 내에서 다수의 프로그램 흐름을 만들어 내기 위해 프로세스 내에 생성한 모델

</br>

> ## 프로세스와 쓰레드의 차이

- 프로세스는 데이터에 관해 서로 완벽히 독립적인 구조이다. 

  쓰레드는 같은 프로세스 내에서 서로 공유하는 요소들이 있다.

- 쓰레드는 공유하는 요소가 있기 때문에 컨텍스트 스위칭이 프로세스보다 빠르다.

</br>

### 쓰레드끼리 공유하는 요소란 무엇인가

메모리 구조상 프로세스는 code영역, data영역, stack영역, heap영역으로 구성됩니다.

쓰레드는 쓰레드가 생성될 때마다 해당 쓰레드를 위한 stack영역을 만들게 되고 나머지 code, data, stack영역은 공유하고 있습니다.

</br>

### 커널 레벨 쓰레드와 유저 레벨 쓰레드의 의미와 특징

**커널 레벨 쓰레드**란, 쓰레드를 생성하고 스케줄링 하는 주체가 커널일 경우를 뜻하고

**유저 레벨 쓰레드**란, 커널에서 쓰레드 기능을 지원하지 않을 때, 커널에 의존하지 않고 라이브러리를 활용하여 쓰레드의 기능을 써서 실행되는 쓰레드를 뜻합니다.

**커널 레벨 쓰레드**는 커널에서 직접 관리해주는 쓰레드이기 때문에 안전성이 뛰어나고 기본으로 제공되는 기능들이 있습니다.

**유저 레벨 쓰레드**는 커널에 의존하지 않기 때문에 커널모드와 유저모드의 전환이 없어서 성능이 좋습니다.

</br>

### 커널 영역과 유저 영역의 차이

커널 영역은 운영체제 동작시 사용하는 메모리 공간을 뜻하고,

유저 영역은 사용자가 원하는 프로그램 동작시 사용되는 메모리 공간(code, data, stack, heap)을 뜻합니다.

</br>

### 커널 모드와 유저 모드의 차이

**커널 모드**는 커널 영역에서 실행이 이뤄져야 할 경우 전환되는 모드이고,

**유저 모드**는 유저 영역에서 실행이 이뤄져야 할 경우 전환되는 모드입니다.

**유저 모드**에서는 커널 영역에 대한 접근이 불가능 하지만,

**커널 모드**에서는 모든 영역에 대한 접근이 가능합니다.

</br>

> ## 쓰레드 동기화

**임계영역**이란 **배타적 접근**(한 순간에 하나의 쓰레드만 접근)이 요구되는 공유 리소스에 접근하는 **코드블록**이다.

</br>

**동기화**란 **임계영역에 대한 동시접근을 막는 것**.

</br>

동기화 기법은 크게 **유저 모드 동기화, 커널 모드 동기화**로 나뉜다.

</br>

### 유저 모드 동기화

동기화 과정에서 커널을 사용하지 않는 동기화 기법. 커널을 사용하지 않기에 **성능상의 이점**이 있지만 **기능상의 제한**도 있다.

종류

- 크리티컬 섹션
- 인터락

### 커널 모드 동기화

동기화 과정에서 커널을 사용하는 동기화 기법. 커널을 사용하기 때문에 **성능의 저하**가 있지만 **커널에서 제공하는 기능**을 사용가능하다.

종류

- 뮤텍스
- 세마포어
- 이름있는 뮤텍스
- 이벤트

</br>

#### 크리티컬 섹션 기반 동기화

```c
CRITICAL_SECTION hCriticalSection;
LONG gTotalCount = 0;

void IncreaseCount(){
    EnterCriticalSection (&hCriticalSection);
    gTotalCount++; //임계영역
    LeaveCriticalSection (&hCriticalSection);
}
```

둘 이상의 쓰레드가 gTotalCount를 접근할 경우 동기화가 필요하다.

</br>

##### EnterCriticalSection

임계영역에 진입하기 위해 크리티컬 섹션 오브젝트의 주소값을 인자로 전달.

EnterCriticalSection이 다른 쓰레드에 의해서 호출된 상태이면, 호출 함수는 블로킹.

**LeaveCriticalSection**

임계영역을 빠져나온 후 호출.

블로킹 상태의 쓰레드가 있다면, 그 쓰레드는 임계영역 진입.

</br>

즉, 임계영역에 접근한 쓰레드가 있는지 확인하고 임계영역에 1개씩 들여보내는 방법.




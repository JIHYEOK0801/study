1. # 인터넷 네트워크

   1. ## IP(인터넷 프로토콜)

      - 지정한 **IP주소**에 데이터 전달
      - **패킷(packet)**이라는 통신단위로 데이터 전달

       

      ### IP 프로토콜의 한계

      - **비연결성**

        패킷을 받을 대상이 없거나 서비스 불능 상태여도 패킷 전송

        대상 서버가 패킷을 받을 수 있는 상태인지 모름

      - **비신뢰성**

        1. 중간에 패킷이 사라지면?
        2. 패킷이 순서대로 안오면?

      - **프로그램 구분**

        같은 IP를 사용하는 서버에서 통신하는 어플리케이션이 둘 이상이면?

        ex) 게임을 하면서 음악도 들을 때

   
   ---
   
   2. ## TCP,UDP
   
      ### TCP 프로토콜 스택의 4계층
   
      각 계층마다 정보를 더해 패킷의 크기를 키워나간다
   
      - 애플리케이션 계층 - HTTP, FTP
   
        ("Hello")
   
        
   
      - 전송계층 - TCP, UDP
   
        출발지 PORT, 목적지 PORT, 전송 제어, 순서, 검증 정보...
   
        [ ("Hello") ]
   
        
   
      - 인터넷 계층 - IP
   
        구성 : 출발지 IP, 목적지 IP, 기타...
   
        { [ ("Hello") ] }
   
        
   
      - 네트워크 인터페이스 계층 - 랜카드, 랜드라이버 등
   
        { [ ("Hello") ] } 전송 -----> 인터넷
   
        
   
      ### TCP 특징
   
      신뢰할 수 있는 프로토콜을 사용하며, 대부분의 어플리케이션에서 거의 TCP를 사용한다.
   
      
   
      - #### **연결지향** - TCP 3way handshake
   
        SYN : 접속 요청
   
        ACK : 요청 수락
   
        
   
        **과정**
   
        1. 클라리언트 >>> 서버 (SYN)
        2. 클라이언트 <<< 서버 (SYN + ACK)
        3. 클라이언트 >>> 서버 (ACK)
        4. 클라이언트 <<< 서버 (데이터 전송)
   
        요즘은 3번 ACK를 보낼때 데이터도 같이 전송함
   
        
   
        **TCP 3way handshake가 성공했다고 진짜 연결 된 것이 아님**
   
        (그냥 논리적인 연결이 됨. 나를 위한 전용 랜선이 있는게 아니다.)
   
        
   
      - #### **데이터 전달 보증**
   
        데이터를 잘 받았는지 응답이 됨
   
        1. 클라이언트 >>> 서버 (데이터 전송)
   
        2. 클라이언트 <<< 서버 (데이터 잘 받았음)
   
           
   
      - #### **순서 보증**
   
        1. 클라이언트 >>> 서버 (패킷1, 패킷2, 패킷3)
        2. 클라이언트 <<< 서버 (패킷1, 패킷3, 패킷2 로 도착했으니 패킷2부터 다시 보내라)
   
      
   
      ###  UDP 특징
   
      - 하얀 도화지에 비유(기능이 거의 없음)
   
      - 연결지향 X
   
      - 데이터 전달 보증 X
   
      - 순서 보장 X
   
      - 데이터 전달 및 순서가 보장되지 않지만 단순하고 빠름
   
      - 정리
   
        IP와 거의 같다 + PORT + 체크섬 정도
   
        어플리케이션에서 추가 작업이 필요
        
        최근 각광받고 있음
   
      ---
   
   3. ## PORT
   
      TCP/IP 패킷에 **출발지 PORT, 목적지 PORT** 있어서 구분이 가능함
   
      0~65535 까지 할당 가능
   
      0~1024 : 잘알려진 포트. 사용하지 않는것이 좋음
   
      - FTP : 20,21
      - TELNET : 23
      - HTTP : 80
      - HTTPS : 443
   
      ---
   
   4. ## DNS
   
      도메인 명을  IP주소로 변환하는 시스템
      
      ---
   
2. # URI와 웹 브라우저 요청 흐름

   1. ## URI

      **URI**는 **로케이터(locator)**, **이름(name)** 또는 둘 다 추가로 분류될 수 있다

      URI(Resource Identifier) { URL (Resource Locator), URN(Resource Name) }으로 생각하면 됨

      

      **U**niform : 리소스를 식별하는 통일된 방식

      **R**esource : 자원, URI로 식별할 수 있는 모든 것(제한 없음)

      **I**dentifier : 다른 항목과 구분하는데 필요한 정보

      

      URL(Uniform Resource Locator) : 리소스가 있는 위치를 지정

      URN(Uniform Resource Name) : 리소스에 이름을 부여

      

      위치는 변할 수 있지만 이름은 변하지 않는다

      **URN 이름만으로 실제 리소스를 찾을 수 있는 방법이 보편화 되어 있지 않다**

      이 강의 내에서는 URI, URL을 같은 의미로 씀

      

      <URL 형식>

      scheme:  // [userinfo@]  host                     [:port]     [/path]          [?query]                 [#fragment]

      https:       //                      www.google.com  :443      /search        ?q=hello&hl=ko

      

      - scheme

        주로 프로토콜 사용. 어떤 방식으로 자원에 접근할 것인가의 규칙

        ex) http, https, ftp 등등

      - userinfo@

        URL에 사용자 정보를 포함해서 인증. 거의 사용 x

      - host

        호스트명. 도메인명 또는 IP주소를 직접 사용 가능

      - port

        접속포트. 일반적으로 생략. 생략시 http - 80, https - 443으로 이해

      - path

        리소스 경로. 계층적 구조로 되어있다

        ex) /home/file1.jpg,  /memebers,  /memebers/100,  /items/iphone12 등

      - query

        key=value 형태

        ?로 시작, &로 추가 가능

        query parameter, query string 등으로 불림, 웹서버에 제공한느 파라미터, 문자형태

      - fragment

        html 내부 북마크 등에 사용

        서버에 전송되는 정보는 아님

      ---

   2. ## 웹 브라우저 요청 흐름

      URL : https://www.google.com/search?q=hello&hl=ko

      1. 웹 브라우저가 "www.google.com"(도메인)을 DNS 조회. IP주소(ex. 200.200.200.2) 획득.

         HTTP 요청메시지를 생성

      2. HTTP메시지를 **SOCKET라이브러리를 통해 전달**

         1. TCP/IP연결 (IP,PORT)
         2. 데이터 전달

      3.  HTTP 메시지를 포함하는 **TCP/IP 패킷 생성**

      4. 인터넷 망으로 전송

      5. 구글 서버에서 HTTP메시지 확인

      6. 구글 서버에서 HTTP 응답 메시지 작성

      7. 응답 패킷 나한테 도착

      8. HTTP 응답 메시지 확인

      ---

3. # HTTP 기본

   1. ## 모든 것이 HTTP

      HTML, TEXT, IMAGE, 음성, 영상, 파일 jSON, XML 거의 모든 형태의 데이터 전송 가능

      서버간에 데이터를 주고 받을 때도 대부분 HTTP 사용

      

      ### 역사

      HTTP/1.1 1997년 : 가장 많이 사용, 우리에게 가장 중요한 버전

      - RFC2068(1997)  >> RFC2616(1999) >> RFC7230~7235(2014)

      HTTP/2 2015년 : 성능 개선

      HTTP/3 진행중 : TCP 대신에 UDP 사용, 성능 개선

      

      ### 기반 프로토콜

      **TCP** : HTTP/1.1, HTTP/2

      **UDP** : HTTP/3

      현재 HTTP/1.1 주로 사용. HTTP/2, HTTP/3 도 점점 증가

      

      ### HTTP 특징

      - 클라이언트 서버 구조
      - 무상태 프로토콜(stateless), 비연결성
      - HTTP 메시지
      - 단순함, 확장 가능

      ---

   2. ## 클라이언트 서버 구조

      Request Response 구조

      - 클라이언트는 서버에 요청을 보내고, 응답을 대기
      - 서버가 요청에 대한 결과를 만들어서 응답

      

      클라이언트는 UI에 집중. 서버는 트래픽, 비즈니스 로직 등에 집중

      ---

   3. ## stateful, stateless

      서버가 클라이언트 상태를 보존하지 않는다(stateless)

      Stateful : 서버가 **클라이언트의 이전상태를 보존하는 것**

      Stateless : 서버가 **클라이언트의 이전상태를 보존하하지 않는 것**

      

      ### Stateful/Sateless

      - 상태유지 : 중간에 다른 점원으로 바뀌면 안된다
      - 무상태 : 중간에 다른 점원으로 바뀌어도 된다
      - 무상태는 응답서버를 쉽게 바꿀 수 있다 >> 무한한 서버 증설 가능

      

      ### Stateless의 한계

      - 무상태

        로그인이 필요 없는 단순한 서비스 소개 화면

      - 상태 유지

        로그인을 하는 경우

      - 로그인한 사용자의 경우 로그인 했다는 상태를 서버에 유지

      - 일반적으로 브라우저 쿠키와 서버 세션 등을 사용하여 상태 유지

      - 상태 유지는 최소한만 사용

      ---

   4. ## 비 연결성(connectionless)

      **TCP/IP**의 경우 **연결을 유지하는 모델**

      서버의 자원을 계속 소모하게 된다

      

      **TCP/IP**의 경우 **연결을 유지하하지 않는 모델**

      서버는 연결유지 X, 최소한의 자원만 유지

      

      **HTTP**의 기본은 **연결을 유지하지 않는 모델**

      일반적으로 초 단위 이하의 빠른속도 응답

      1시간 동안 수천명이 서비스를 사용해도 실제 서버에서 동시에 처리하는 요청은 수십개 이하

      ​	ex) 웹브라우저에서 계속 수천명이 연속해서 검색버튼을 누르지 않음

      **서버 자원을 매우 효율적으로 사용 가능**하다

      

      ### 한계와 극복

      - TCP/IP 연결을 새로 맺어야 함 - 3 way handshake 시간 추가
      - 웹 브라우저로 사이트를 요청하면 HTML 뿐만 아니라 js script, css, 이미지 등을 함께 다운로드
      - 지금은 HTTP 지속연결로 문제 해결
      - HTTP/2, HTTP/3 에서 더 많은 최적화

      

      ### Stateless를 기억하자

      - 같은 시간에 딱 맞추어 발생하는 대용량 트래픽

        ex. 선착순 이벤트, 명절 KTX 예약, 학과 수업 등록 등등

      - 최다한 Stateless하게 설계해야 한다

      ---

   5. ## HTTP 메시지

      ### HTTP 메시지 구조

      - start-line 시작라인
      - header 헤더
      - empty line 공백 라인(CRLF)
      - message body

      

      ### start-line(시작 라인)

      - #### 요청메시지

        **request-line** / status-line

        **request-line** = **method** SP(공백) **request-target** SP **HTTP-version** CRLF(엔터)

        - method (HTTP 메서드)

          서버가 수행해야 할 동작 지정

          ex. GET : 리소스 조회, POST : 요청 내역 처리 등

        - 요청 대상

          절대 경로 = "/"로 시작하는 경로

        - HTTP Version

          

      - #### 응답메시지

        request-line / **status-line**

        **status-line** = **HTTP-version** SP **status-code** SP **reason-phrase** CRLF

        - HTTP 버전

        - HTTP 상태 코드

          200 : 성공

          400 : 클라이언트 요청 오류

          500 : 서버 내부 오류

        - 이유 문구 : 짧은 글 (ex. OK)

          

      ### header(HTTP 헤더)

      header-field = **field-name:** OWS **field-value** OWS (OWS:띄어쓰기 허용)

      **헤더의 용도**

      - HTTP 전송에 필요한 모든 부가 정보

        ex. 메시지 바디 내용, 메시지 바디 크기 등등

        메시지 바디 내용 말고 모든 메타데이터가 들어가 있다고 생각

      - 표준 헤더가 매우 많다

      - 필요시 임의의 헤더 추가 가능

        

      ### message body(HTTP 메시지 바디)

      **바디의 용도**

      - 실제 전송할 데이터
      - HTML 문서, 이미지, 영상, JSON 등등 byte로 표현할 수 있는 모든 데이터 전송 가능

      

      

      ### 단순함 확장 가능

      HTTP는 단순하지만 확장 가능한 기술이다

      ---